/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export declare namespace Types {
  export type BlockLeafStruct = {
    blockHash: BytesLike;
    height: BigNumberish;
    cumulativeChainwork: BigNumberish;
  };

  export type BlockLeafStructOutput = [
    blockHash: string,
    height: bigint,
    cumulativeChainwork: bigint
  ] & { blockHash: string; height: bigint; cumulativeChainwork: bigint };

  export type DepositLiquidityParamsStruct = {
    depositOwnerAddress: AddressLike;
    specifiedPayoutAddress: AddressLike;
    depositAmount: BigNumberish;
    expectedSats: BigNumberish;
    btcPayoutScriptPubKey: BytesLike;
    depositSalt: BytesLike;
    confirmationBlocks: BigNumberish;
    safeBlockLeaf: Types.BlockLeafStruct;
    safeBlockSiblings: BytesLike[];
    safeBlockPeaks: BytesLike[];
  };

  export type DepositLiquidityParamsStructOutput = [
    depositOwnerAddress: string,
    specifiedPayoutAddress: string,
    depositAmount: bigint,
    expectedSats: bigint,
    btcPayoutScriptPubKey: string,
    depositSalt: string,
    confirmationBlocks: bigint,
    safeBlockLeaf: Types.BlockLeafStructOutput,
    safeBlockSiblings: string[],
    safeBlockPeaks: string[]
  ] & {
    depositOwnerAddress: string;
    specifiedPayoutAddress: string;
    depositAmount: bigint;
    expectedSats: bigint;
    btcPayoutScriptPubKey: string;
    depositSalt: string;
    confirmationBlocks: bigint;
    safeBlockLeaf: Types.BlockLeafStructOutput;
    safeBlockSiblings: string[];
    safeBlockPeaks: string[];
  };

  export type DepositVaultStruct = {
    vaultIndex: BigNumberish;
    depositTimestamp: BigNumberish;
    depositAmount: BigNumberish;
    depositFee: BigNumberish;
    expectedSats: BigNumberish;
    btcPayoutScriptPubKey: BytesLike;
    specifiedPayoutAddress: AddressLike;
    ownerAddress: AddressLike;
    salt: BytesLike;
    confirmationBlocks: BigNumberish;
    attestedBitcoinBlockHeight: BigNumberish;
  };

  export type DepositVaultStructOutput = [
    vaultIndex: bigint,
    depositTimestamp: bigint,
    depositAmount: bigint,
    depositFee: bigint,
    expectedSats: bigint,
    btcPayoutScriptPubKey: string,
    specifiedPayoutAddress: string,
    ownerAddress: string,
    salt: string,
    confirmationBlocks: bigint,
    attestedBitcoinBlockHeight: bigint
  ] & {
    vaultIndex: bigint;
    depositTimestamp: bigint;
    depositAmount: bigint;
    depositFee: bigint;
    expectedSats: bigint;
    btcPayoutScriptPubKey: string;
    specifiedPayoutAddress: string;
    ownerAddress: string;
    salt: string;
    confirmationBlocks: bigint;
    attestedBitcoinBlockHeight: bigint;
  };

  export type DepositLiquidityWithOverwriteParamsStruct = {
    depositParams: Types.DepositLiquidityParamsStruct;
    overwriteVault: Types.DepositVaultStruct;
  };

  export type DepositLiquidityWithOverwriteParamsStructOutput = [
    depositParams: Types.DepositLiquidityParamsStructOutput,
    overwriteVault: Types.DepositVaultStructOutput
  ] & {
    depositParams: Types.DepositLiquidityParamsStructOutput;
    overwriteVault: Types.DepositVaultStructOutput;
  };

  export type ProposedSwapStruct = {
    swapIndex: BigNumberish;
    depositVaultCommitment: BytesLike;
    swapBitcoinBlockHash: BytesLike;
    confirmationBlocks: BigNumberish;
    liquidityUnlockTimestamp: BigNumberish;
    specifiedPayoutAddress: AddressLike;
    totalSwapFee: BigNumberish;
    totalSwapOutput: BigNumberish;
    state: BigNumberish;
  };

  export type ProposedSwapStructOutput = [
    swapIndex: bigint,
    depositVaultCommitment: string,
    swapBitcoinBlockHash: string,
    confirmationBlocks: bigint,
    liquidityUnlockTimestamp: bigint,
    specifiedPayoutAddress: string,
    totalSwapFee: bigint,
    totalSwapOutput: bigint,
    state: bigint
  ] & {
    swapIndex: bigint;
    depositVaultCommitment: string;
    swapBitcoinBlockHash: string;
    confirmationBlocks: bigint;
    liquidityUnlockTimestamp: bigint;
    specifiedPayoutAddress: string;
    totalSwapFee: bigint;
    totalSwapOutput: bigint;
    state: bigint;
  };

  export type ReleaseLiquidityParamsStruct = {
    swap: Types.ProposedSwapStruct;
    swapBlockChainwork: BigNumberish;
    swapBlockHeight: BigNumberish;
    bitcoinSwapBlockSiblings: BytesLike[];
    bitcoinSwapBlockPeaks: BytesLike[];
    utilizedVault: Types.DepositVaultStruct;
    tipBlockHeight: BigNumberish;
  };

  export type ReleaseLiquidityParamsStructOutput = [
    swap: Types.ProposedSwapStructOutput,
    swapBlockChainwork: bigint,
    swapBlockHeight: bigint,
    bitcoinSwapBlockSiblings: string[],
    bitcoinSwapBlockPeaks: string[],
    utilizedVault: Types.DepositVaultStructOutput,
    tipBlockHeight: bigint
  ] & {
    swap: Types.ProposedSwapStructOutput;
    swapBlockChainwork: bigint;
    swapBlockHeight: bigint;
    bitcoinSwapBlockSiblings: string[];
    bitcoinSwapBlockPeaks: string[];
    utilizedVault: Types.DepositVaultStructOutput;
    tipBlockHeight: bigint;
  };

  export type SubmitSwapProofParamsStruct = {
    swapBitcoinTxid: BytesLike;
    vault: Types.DepositVaultStruct;
    storageStrategy: BigNumberish;
    localOverwriteIndex: BigNumberish;
    swapBitcoinBlockLeaf: Types.BlockLeafStruct;
    swapBitcoinBlockSiblings: BytesLike[];
    swapBitcoinBlockPeaks: BytesLike[];
  };

  export type SubmitSwapProofParamsStructOutput = [
    swapBitcoinTxid: string,
    vault: Types.DepositVaultStructOutput,
    storageStrategy: bigint,
    localOverwriteIndex: bigint,
    swapBitcoinBlockLeaf: Types.BlockLeafStructOutput,
    swapBitcoinBlockSiblings: string[],
    swapBitcoinBlockPeaks: string[]
  ] & {
    swapBitcoinTxid: string;
    vault: Types.DepositVaultStructOutput;
    storageStrategy: bigint;
    localOverwriteIndex: bigint;
    swapBitcoinBlockLeaf: Types.BlockLeafStructOutput;
    swapBitcoinBlockSiblings: string[];
    swapBitcoinBlockPeaks: string[];
  };

  export type BlockProofParamsStruct = {
    priorMmrRoot: BytesLike;
    newMmrRoot: BytesLike;
    compressedBlockLeaves: BytesLike;
    tipBlockLeaf: Types.BlockLeafStruct;
  };

  export type BlockProofParamsStructOutput = [
    priorMmrRoot: string,
    newMmrRoot: string,
    compressedBlockLeaves: string,
    tipBlockLeaf: Types.BlockLeafStructOutput
  ] & {
    priorMmrRoot: string;
    newMmrRoot: string;
    compressedBlockLeaves: string;
    tipBlockLeaf: Types.BlockLeafStructOutput;
  };
}

export interface IRiftExchangeInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "CIRCUIT_VERIFICATION_KEY"
      | "DEPOSIT_TOKEN"
      | "FEE_ROUTER_ADDRESS"
      | "TOKEN_DECIMALS"
      | "VERIFIER"
      | "accumulatedFeeBalance"
      | "depositLiquidity"
      | "depositLiquidityWithOverwrite"
      | "getLightClientHeight"
      | "getSwapCommitment"
      | "getSwapCommitmentsLength"
      | "getVaultCommitment"
      | "getVaultCommitmentsLength"
      | "payoutToFeeRouter"
      | "releaseLiquidityBatch"
      | "submitBatchSwapProof"
      | "submitBatchSwapProofWithLightClientUpdate"
      | "swapCommitments"
      | "updateLightClient"
      | "vaultCommitments"
      | "withdrawLiquidity"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "CIRCUIT_VERIFICATION_KEY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DEPOSIT_TOKEN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FEE_ROUTER_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TOKEN_DECIMALS",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "VERIFIER", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "accumulatedFeeBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "depositLiquidity",
    values: [Types.DepositLiquidityParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "depositLiquidityWithOverwrite",
    values: [Types.DepositLiquidityWithOverwriteParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getLightClientHeight",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapCommitment",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapCommitmentsLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultCommitment",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultCommitmentsLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "payoutToFeeRouter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "releaseLiquidityBatch",
    values: [Types.ReleaseLiquidityParamsStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "submitBatchSwapProof",
    values: [
      Types.SubmitSwapProofParamsStruct[],
      Types.ProposedSwapStruct[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitBatchSwapProofWithLightClientUpdate",
    values: [
      Types.SubmitSwapProofParamsStruct[],
      Types.BlockProofParamsStruct,
      Types.ProposedSwapStruct[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapCommitments",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateLightClient",
    values: [Types.BlockProofParamsStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultCommitments",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawLiquidity",
    values: [Types.DepositVaultStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "CIRCUIT_VERIFICATION_KEY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DEPOSIT_TOKEN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FEE_ROUTER_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TOKEN_DECIMALS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "VERIFIER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "accumulatedFeeBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositLiquidityWithOverwrite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLightClientHeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwapCommitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwapCommitmentsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultCommitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultCommitmentsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "payoutToFeeRouter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseLiquidityBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitBatchSwapProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitBatchSwapProofWithLightClientUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapCommitments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateLightClient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultCommitments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawLiquidity",
    data: BytesLike
  ): Result;
}

export interface IRiftExchange extends BaseContract {
  connect(runner?: ContractRunner | null): IRiftExchange;
  waitForDeployment(): Promise<this>;

  interface: IRiftExchangeInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  CIRCUIT_VERIFICATION_KEY: TypedContractMethod<[], [string], "view">;

  DEPOSIT_TOKEN: TypedContractMethod<[], [string], "view">;

  FEE_ROUTER_ADDRESS: TypedContractMethod<[], [string], "view">;

  TOKEN_DECIMALS: TypedContractMethod<[], [bigint], "view">;

  VERIFIER: TypedContractMethod<[], [string], "view">;

  accumulatedFeeBalance: TypedContractMethod<[], [bigint], "view">;

  depositLiquidity: TypedContractMethod<
    [params: Types.DepositLiquidityParamsStruct],
    [void],
    "nonpayable"
  >;

  depositLiquidityWithOverwrite: TypedContractMethod<
    [params: Types.DepositLiquidityWithOverwriteParamsStruct],
    [void],
    "nonpayable"
  >;

  getLightClientHeight: TypedContractMethod<[], [bigint], "view">;

  getSwapCommitment: TypedContractMethod<
    [swapIndex: BigNumberish],
    [string],
    "view"
  >;

  getSwapCommitmentsLength: TypedContractMethod<[], [bigint], "view">;

  getVaultCommitment: TypedContractMethod<
    [vaultIndex: BigNumberish],
    [string],
    "view"
  >;

  getVaultCommitmentsLength: TypedContractMethod<[], [bigint], "view">;

  payoutToFeeRouter: TypedContractMethod<[], [void], "nonpayable">;

  releaseLiquidityBatch: TypedContractMethod<
    [paramsArray: Types.ReleaseLiquidityParamsStruct[]],
    [void],
    "nonpayable"
  >;

  submitBatchSwapProof: TypedContractMethod<
    [
      swapParams: Types.SubmitSwapProofParamsStruct[],
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  submitBatchSwapProofWithLightClientUpdate: TypedContractMethod<
    [
      swapParams: Types.SubmitSwapProofParamsStruct[],
      blockProofParams: Types.BlockProofParamsStruct,
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  swapCommitments: TypedContractMethod<[index: BigNumberish], [string], "view">;

  updateLightClient: TypedContractMethod<
    [blockProofParams: Types.BlockProofParamsStruct, proof: BytesLike],
    [void],
    "nonpayable"
  >;

  vaultCommitments: TypedContractMethod<
    [index: BigNumberish],
    [string],
    "view"
  >;

  withdrawLiquidity: TypedContractMethod<
    [vault: Types.DepositVaultStruct],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "CIRCUIT_VERIFICATION_KEY"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "DEPOSIT_TOKEN"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "FEE_ROUTER_ADDRESS"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "TOKEN_DECIMALS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "VERIFIER"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "accumulatedFeeBalance"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "depositLiquidity"
  ): TypedContractMethod<
    [params: Types.DepositLiquidityParamsStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "depositLiquidityWithOverwrite"
  ): TypedContractMethod<
    [params: Types.DepositLiquidityWithOverwriteParamsStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getLightClientHeight"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getSwapCommitment"
  ): TypedContractMethod<[swapIndex: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getSwapCommitmentsLength"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getVaultCommitment"
  ): TypedContractMethod<[vaultIndex: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getVaultCommitmentsLength"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "payoutToFeeRouter"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "releaseLiquidityBatch"
  ): TypedContractMethod<
    [paramsArray: Types.ReleaseLiquidityParamsStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "submitBatchSwapProof"
  ): TypedContractMethod<
    [
      swapParams: Types.SubmitSwapProofParamsStruct[],
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "submitBatchSwapProofWithLightClientUpdate"
  ): TypedContractMethod<
    [
      swapParams: Types.SubmitSwapProofParamsStruct[],
      blockProofParams: Types.BlockProofParamsStruct,
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "swapCommitments"
  ): TypedContractMethod<[index: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "updateLightClient"
  ): TypedContractMethod<
    [blockProofParams: Types.BlockProofParamsStruct, proof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "vaultCommitments"
  ): TypedContractMethod<[index: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "withdrawLiquidity"
  ): TypedContractMethod<
    [vault: Types.DepositVaultStruct],
    [void],
    "nonpayable"
  >;

  filters: {};
}
