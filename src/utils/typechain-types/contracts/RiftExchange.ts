/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace Types {
  export type BlockLeafStruct = {
    blockHash: BytesLike;
    height: BigNumberish;
    cumulativeChainwork: BigNumberish;
  };

  export type BlockLeafStructOutput = [string, number, BigNumber] & {
    blockHash: string;
    height: number;
    cumulativeChainwork: BigNumber;
  };

  export type ProposedSwapStruct = {
    swapIndex: BigNumberish;
    depositVaultCommitment: BytesLike;
    swapBitcoinBlockHash: BytesLike;
    confirmationBlocks: BigNumberish;
    liquidityUnlockTimestamp: BigNumberish;
    specifiedPayoutAddress: string;
    totalSwapFee: BigNumberish;
    totalSwapOutput: BigNumberish;
    state: BigNumberish;
  };

  export type ProposedSwapStructOutput = [
    BigNumber,
    string,
    string,
    number,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    number
  ] & {
    swapIndex: BigNumber;
    depositVaultCommitment: string;
    swapBitcoinBlockHash: string;
    confirmationBlocks: number;
    liquidityUnlockTimestamp: BigNumber;
    specifiedPayoutAddress: string;
    totalSwapFee: BigNumber;
    totalSwapOutput: BigNumber;
    state: number;
  };

  export type DepositVaultStruct = {
    vaultIndex: BigNumberish;
    depositTimestamp: BigNumberish;
    depositAmount: BigNumberish;
    depositFee: BigNumberish;
    expectedSats: BigNumberish;
    btcPayoutScriptPubKey: BytesLike;
    specifiedPayoutAddress: string;
    ownerAddress: string;
    salt: BytesLike;
    confirmationBlocks: BigNumberish;
    attestedBitcoinBlockHeight: BigNumberish;
  };

  export type DepositVaultStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string,
    number,
    BigNumber
  ] & {
    vaultIndex: BigNumber;
    depositTimestamp: BigNumber;
    depositAmount: BigNumber;
    depositFee: BigNumber;
    expectedSats: BigNumber;
    btcPayoutScriptPubKey: string;
    specifiedPayoutAddress: string;
    ownerAddress: string;
    salt: string;
    confirmationBlocks: number;
    attestedBitcoinBlockHeight: BigNumber;
  };

  export type DepositLiquidityParamsStruct = {
    depositOwnerAddress: string;
    specifiedPayoutAddress: string;
    depositAmount: BigNumberish;
    expectedSats: BigNumberish;
    btcPayoutScriptPubKey: BytesLike;
    depositSalt: BytesLike;
    confirmationBlocks: BigNumberish;
    safeBlockLeaf: Types.BlockLeafStruct;
    safeBlockSiblings: BytesLike[];
    safeBlockPeaks: BytesLike[];
  };

  export type DepositLiquidityParamsStructOutput = [
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    string,
    number,
    Types.BlockLeafStructOutput,
    string[],
    string[]
  ] & {
    depositOwnerAddress: string;
    specifiedPayoutAddress: string;
    depositAmount: BigNumber;
    expectedSats: BigNumber;
    btcPayoutScriptPubKey: string;
    depositSalt: string;
    confirmationBlocks: number;
    safeBlockLeaf: Types.BlockLeafStructOutput;
    safeBlockSiblings: string[];
    safeBlockPeaks: string[];
  };

  export type DepositLiquidityWithOverwriteParamsStruct = {
    depositParams: Types.DepositLiquidityParamsStruct;
    overwriteVault: Types.DepositVaultStruct;
  };

  export type DepositLiquidityWithOverwriteParamsStructOutput = [
    Types.DepositLiquidityParamsStructOutput,
    Types.DepositVaultStructOutput
  ] & {
    depositParams: Types.DepositLiquidityParamsStructOutput;
    overwriteVault: Types.DepositVaultStructOutput;
  };

  export type ReleaseLiquidityParamsStruct = {
    swap: Types.ProposedSwapStruct;
    swapBlockChainwork: BigNumberish;
    swapBlockHeight: BigNumberish;
    bitcoinSwapBlockSiblings: BytesLike[];
    bitcoinSwapBlockPeaks: BytesLike[];
    utilizedVault: Types.DepositVaultStruct;
    tipBlockHeight: BigNumberish;
  };

  export type ReleaseLiquidityParamsStructOutput = [
    Types.ProposedSwapStructOutput,
    BigNumber,
    number,
    string[],
    string[],
    Types.DepositVaultStructOutput,
    number
  ] & {
    swap: Types.ProposedSwapStructOutput;
    swapBlockChainwork: BigNumber;
    swapBlockHeight: number;
    bitcoinSwapBlockSiblings: string[];
    bitcoinSwapBlockPeaks: string[];
    utilizedVault: Types.DepositVaultStructOutput;
    tipBlockHeight: number;
  };

  export type SubmitSwapProofParamsStruct = {
    swapBitcoinTxid: BytesLike;
    vault: Types.DepositVaultStruct;
    storageStrategy: BigNumberish;
    localOverwriteIndex: BigNumberish;
    swapBitcoinBlockLeaf: Types.BlockLeafStruct;
    swapBitcoinBlockSiblings: BytesLike[];
    swapBitcoinBlockPeaks: BytesLike[];
  };

  export type SubmitSwapProofParamsStructOutput = [
    string,
    Types.DepositVaultStructOutput,
    number,
    number,
    Types.BlockLeafStructOutput,
    string[],
    string[]
  ] & {
    swapBitcoinTxid: string;
    vault: Types.DepositVaultStructOutput;
    storageStrategy: number;
    localOverwriteIndex: number;
    swapBitcoinBlockLeaf: Types.BlockLeafStructOutput;
    swapBitcoinBlockSiblings: string[];
    swapBitcoinBlockPeaks: string[];
  };

  export type BlockProofParamsStruct = {
    priorMmrRoot: BytesLike;
    newMmrRoot: BytesLike;
    compressedBlockLeaves: BytesLike;
    tipBlockLeaf: Types.BlockLeafStruct;
  };

  export type BlockProofParamsStructOutput = [
    string,
    string,
    string,
    Types.BlockLeafStructOutput
  ] & {
    priorMmrRoot: string;
    newMmrRoot: string;
    compressedBlockLeaves: string;
    tipBlockLeaf: Types.BlockLeafStructOutput;
  };
}

export interface RiftExchangeInterface extends utils.Interface {
  functions: {
    "CIRCUIT_VERIFICATION_KEY()": FunctionFragment;
    "DEPOSIT_TOKEN()": FunctionFragment;
    "FEE_ROUTER_ADDRESS()": FunctionFragment;
    "TOKEN_DECIMALS()": FunctionFragment;
    "VERIFIER()": FunctionFragment;
    "accumulatedFeeBalance()": FunctionFragment;
    "checkpoints(bytes32)": FunctionFragment;
    "depositLiquidity((address,address,uint256,uint64,bytes22,bytes32,uint8,(bytes32,uint32,uint256),bytes32[],bytes32[]))": FunctionFragment;
    "depositLiquidityWithOverwrite(((address,address,uint256,uint64,bytes22,bytes32,uint8,(bytes32,uint32,uint256),bytes32[],bytes32[]),(uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64)))": FunctionFragment;
    "getLightClientHeight()": FunctionFragment;
    "getSwapCommitment(uint256)": FunctionFragment;
    "getSwapCommitmentsLength()": FunctionFragment;
    "getVaultCommitment(uint256)": FunctionFragment;
    "getVaultCommitmentsLength()": FunctionFragment;
    "mmrRoot()": FunctionFragment;
    "payoutToFeeRouter()": FunctionFragment;
    "proveBlockInclusion((bytes32,uint32,uint256),bytes32[],bytes32[])": FunctionFragment;
    "releaseLiquidityBatch(((uint256,bytes32,bytes32,uint8,uint64,address,uint256,uint256,uint8),uint256,uint32,bytes32[],bytes32[],(uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64),uint32)[])": FunctionFragment;
    "submitBatchSwapProof((bytes32,(uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64),uint8,uint16,(bytes32,uint32,uint256),bytes32[],bytes32[])[],(uint256,bytes32,bytes32,uint8,uint64,address,uint256,uint256,uint8)[],bytes)": FunctionFragment;
    "submitBatchSwapProofWithLightClientUpdate((bytes32,(uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64),uint8,uint16,(bytes32,uint32,uint256),bytes32[],bytes32[])[],(bytes32,bytes32,bytes,(bytes32,uint32,uint256)),(uint256,bytes32,bytes32,uint8,uint64,address,uint256,uint256,uint8)[],bytes)": FunctionFragment;
    "swapCommitments(uint256)": FunctionFragment;
    "updateLightClient((bytes32,bytes32,bytes,(bytes32,uint32,uint256)),bytes)": FunctionFragment;
    "vaultCommitments(uint256)": FunctionFragment;
    "withdrawLiquidity((uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "CIRCUIT_VERIFICATION_KEY"
      | "DEPOSIT_TOKEN"
      | "FEE_ROUTER_ADDRESS"
      | "TOKEN_DECIMALS"
      | "VERIFIER"
      | "accumulatedFeeBalance"
      | "checkpoints"
      | "depositLiquidity"
      | "depositLiquidityWithOverwrite"
      | "getLightClientHeight"
      | "getSwapCommitment"
      | "getSwapCommitmentsLength"
      | "getVaultCommitment"
      | "getVaultCommitmentsLength"
      | "mmrRoot"
      | "payoutToFeeRouter"
      | "proveBlockInclusion"
      | "releaseLiquidityBatch"
      | "submitBatchSwapProof"
      | "submitBatchSwapProofWithLightClientUpdate"
      | "swapCommitments"
      | "updateLightClient"
      | "vaultCommitments"
      | "withdrawLiquidity"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "CIRCUIT_VERIFICATION_KEY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DEPOSIT_TOKEN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FEE_ROUTER_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "TOKEN_DECIMALS",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "VERIFIER", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "accumulatedFeeBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "checkpoints",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "depositLiquidity",
    values: [Types.DepositLiquidityParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "depositLiquidityWithOverwrite",
    values: [Types.DepositLiquidityWithOverwriteParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getLightClientHeight",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapCommitment",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapCommitmentsLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultCommitment",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultCommitmentsLength",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "mmrRoot", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "payoutToFeeRouter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proveBlockInclusion",
    values: [Types.BlockLeafStruct, BytesLike[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "releaseLiquidityBatch",
    values: [Types.ReleaseLiquidityParamsStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "submitBatchSwapProof",
    values: [
      Types.SubmitSwapProofParamsStruct[],
      Types.ProposedSwapStruct[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitBatchSwapProofWithLightClientUpdate",
    values: [
      Types.SubmitSwapProofParamsStruct[],
      Types.BlockProofParamsStruct,
      Types.ProposedSwapStruct[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapCommitments",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateLightClient",
    values: [Types.BlockProofParamsStruct, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultCommitments",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawLiquidity",
    values: [Types.DepositVaultStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "CIRCUIT_VERIFICATION_KEY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DEPOSIT_TOKEN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FEE_ROUTER_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "TOKEN_DECIMALS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "VERIFIER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "accumulatedFeeBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkpoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositLiquidityWithOverwrite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLightClientHeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwapCommitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwapCommitmentsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultCommitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultCommitmentsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mmrRoot", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payoutToFeeRouter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveBlockInclusion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseLiquidityBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitBatchSwapProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitBatchSwapProofWithLightClientUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapCommitments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateLightClient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultCommitments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawLiquidity",
    data: BytesLike
  ): Result;

  events: {
    "BitcoinLightClientUpdated(bytes32,bytes32,bytes)": EventFragment;
    "SwapsUpdated((uint256,bytes32,bytes32,uint8,uint64,address,uint256,uint256,uint8)[],uint8)": EventFragment;
    "VaultsUpdated((uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64)[],uint8)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BitcoinLightClientUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultsUpdated"): EventFragment;
}

export interface BitcoinLightClientUpdatedEventObject {
  priorMmrRoot: string;
  newMmrRoot: string;
  compressedBlockLeaves: string;
}
export type BitcoinLightClientUpdatedEvent = TypedEvent<
  [string, string, string],
  BitcoinLightClientUpdatedEventObject
>;

export type BitcoinLightClientUpdatedEventFilter =
  TypedEventFilter<BitcoinLightClientUpdatedEvent>;

export interface SwapsUpdatedEventObject {
  swaps: Types.ProposedSwapStructOutput[];
  context: number;
}
export type SwapsUpdatedEvent = TypedEvent<
  [Types.ProposedSwapStructOutput[], number],
  SwapsUpdatedEventObject
>;

export type SwapsUpdatedEventFilter = TypedEventFilter<SwapsUpdatedEvent>;

export interface VaultsUpdatedEventObject {
  vaults: Types.DepositVaultStructOutput[];
  context: number;
}
export type VaultsUpdatedEvent = TypedEvent<
  [Types.DepositVaultStructOutput[], number],
  VaultsUpdatedEventObject
>;

export type VaultsUpdatedEventFilter = TypedEventFilter<VaultsUpdatedEvent>;

export interface RiftExchange extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RiftExchangeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CIRCUIT_VERIFICATION_KEY(overrides?: CallOverrides): Promise<[string]>;

    DEPOSIT_TOKEN(overrides?: CallOverrides): Promise<[string]>;

    FEE_ROUTER_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    TOKEN_DECIMALS(overrides?: CallOverrides): Promise<[number]>;

    VERIFIER(overrides?: CallOverrides): Promise<[string]>;

    accumulatedFeeBalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    checkpoints(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, Types.BlockLeafStructOutput] & {
        established: boolean;
        tipBlockLeaf: Types.BlockLeafStructOutput;
      }
    >;

    depositLiquidity(
      params: Types.DepositLiquidityParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    depositLiquidityWithOverwrite(
      params: Types.DepositLiquidityWithOverwriteParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getLightClientHeight(overrides?: CallOverrides): Promise<[number]>;

    getSwapCommitment(
      swapIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getSwapCommitmentsLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    getVaultCommitment(
      vaultIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getVaultCommitmentsLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    mmrRoot(overrides?: CallOverrides): Promise<[string]>;

    payoutToFeeRouter(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    proveBlockInclusion(
      blockLeaf: Types.BlockLeafStruct,
      siblings: BytesLike[],
      peaks: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    releaseLiquidityBatch(
      paramsArray: Types.ReleaseLiquidityParamsStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    submitBatchSwapProof(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    submitBatchSwapProofWithLightClientUpdate(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      blockProofParams: Types.BlockProofParamsStruct,
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    swapCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    updateLightClient(
      blockProofParams: Types.BlockProofParamsStruct,
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    vaultCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    withdrawLiquidity(
      vault: Types.DepositVaultStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  CIRCUIT_VERIFICATION_KEY(overrides?: CallOverrides): Promise<string>;

  DEPOSIT_TOKEN(overrides?: CallOverrides): Promise<string>;

  FEE_ROUTER_ADDRESS(overrides?: CallOverrides): Promise<string>;

  TOKEN_DECIMALS(overrides?: CallOverrides): Promise<number>;

  VERIFIER(overrides?: CallOverrides): Promise<string>;

  accumulatedFeeBalance(overrides?: CallOverrides): Promise<BigNumber>;

  checkpoints(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [boolean, Types.BlockLeafStructOutput] & {
      established: boolean;
      tipBlockLeaf: Types.BlockLeafStructOutput;
    }
  >;

  depositLiquidity(
    params: Types.DepositLiquidityParamsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  depositLiquidityWithOverwrite(
    params: Types.DepositLiquidityWithOverwriteParamsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getLightClientHeight(overrides?: CallOverrides): Promise<number>;

  getSwapCommitment(
    swapIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  getSwapCommitmentsLength(overrides?: CallOverrides): Promise<BigNumber>;

  getVaultCommitment(
    vaultIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  getVaultCommitmentsLength(overrides?: CallOverrides): Promise<BigNumber>;

  mmrRoot(overrides?: CallOverrides): Promise<string>;

  payoutToFeeRouter(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  proveBlockInclusion(
    blockLeaf: Types.BlockLeafStruct,
    siblings: BytesLike[],
    peaks: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  releaseLiquidityBatch(
    paramsArray: Types.ReleaseLiquidityParamsStruct[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  submitBatchSwapProof(
    swapParams: Types.SubmitSwapProofParamsStruct[],
    overwriteSwaps: Types.ProposedSwapStruct[],
    proof: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  submitBatchSwapProofWithLightClientUpdate(
    swapParams: Types.SubmitSwapProofParamsStruct[],
    blockProofParams: Types.BlockProofParamsStruct,
    overwriteSwaps: Types.ProposedSwapStruct[],
    proof: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  swapCommitments(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  updateLightClient(
    blockProofParams: Types.BlockProofParamsStruct,
    proof: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  vaultCommitments(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  withdrawLiquidity(
    vault: Types.DepositVaultStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    CIRCUIT_VERIFICATION_KEY(overrides?: CallOverrides): Promise<string>;

    DEPOSIT_TOKEN(overrides?: CallOverrides): Promise<string>;

    FEE_ROUTER_ADDRESS(overrides?: CallOverrides): Promise<string>;

    TOKEN_DECIMALS(overrides?: CallOverrides): Promise<number>;

    VERIFIER(overrides?: CallOverrides): Promise<string>;

    accumulatedFeeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    checkpoints(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, Types.BlockLeafStructOutput] & {
        established: boolean;
        tipBlockLeaf: Types.BlockLeafStructOutput;
      }
    >;

    depositLiquidity(
      params: Types.DepositLiquidityParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    depositLiquidityWithOverwrite(
      params: Types.DepositLiquidityWithOverwriteParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    getLightClientHeight(overrides?: CallOverrides): Promise<number>;

    getSwapCommitment(
      swapIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getSwapCommitmentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultCommitment(
      vaultIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getVaultCommitmentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    mmrRoot(overrides?: CallOverrides): Promise<string>;

    payoutToFeeRouter(overrides?: CallOverrides): Promise<void>;

    proveBlockInclusion(
      blockLeaf: Types.BlockLeafStruct,
      siblings: BytesLike[],
      peaks: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    releaseLiquidityBatch(
      paramsArray: Types.ReleaseLiquidityParamsStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    submitBatchSwapProof(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    submitBatchSwapProofWithLightClientUpdate(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      blockProofParams: Types.BlockProofParamsStruct,
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    swapCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    updateLightClient(
      blockProofParams: Types.BlockProofParamsStruct,
      proof: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    vaultCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    withdrawLiquidity(
      vault: Types.DepositVaultStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "BitcoinLightClientUpdated(bytes32,bytes32,bytes)"(
      priorMmrRoot?: null,
      newMmrRoot?: null,
      compressedBlockLeaves?: null
    ): BitcoinLightClientUpdatedEventFilter;
    BitcoinLightClientUpdated(
      priorMmrRoot?: null,
      newMmrRoot?: null,
      compressedBlockLeaves?: null
    ): BitcoinLightClientUpdatedEventFilter;

    "SwapsUpdated((uint256,bytes32,bytes32,uint8,uint64,address,uint256,uint256,uint8)[],uint8)"(
      swaps?: null,
      context?: null
    ): SwapsUpdatedEventFilter;
    SwapsUpdated(swaps?: null, context?: null): SwapsUpdatedEventFilter;

    "VaultsUpdated((uint256,uint64,uint256,uint256,uint64,bytes22,address,address,bytes32,uint8,uint64)[],uint8)"(
      vaults?: null,
      context?: null
    ): VaultsUpdatedEventFilter;
    VaultsUpdated(vaults?: null, context?: null): VaultsUpdatedEventFilter;
  };

  estimateGas: {
    CIRCUIT_VERIFICATION_KEY(overrides?: CallOverrides): Promise<BigNumber>;

    DEPOSIT_TOKEN(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_ROUTER_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    TOKEN_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    VERIFIER(overrides?: CallOverrides): Promise<BigNumber>;

    accumulatedFeeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    checkpoints(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    depositLiquidity(
      params: Types.DepositLiquidityParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    depositLiquidityWithOverwrite(
      params: Types.DepositLiquidityWithOverwriteParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getLightClientHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getSwapCommitment(
      swapIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSwapCommitmentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultCommitment(
      vaultIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultCommitmentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    mmrRoot(overrides?: CallOverrides): Promise<BigNumber>;

    payoutToFeeRouter(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    proveBlockInclusion(
      blockLeaf: Types.BlockLeafStruct,
      siblings: BytesLike[],
      peaks: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    releaseLiquidityBatch(
      paramsArray: Types.ReleaseLiquidityParamsStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    submitBatchSwapProof(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    submitBatchSwapProofWithLightClientUpdate(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      blockProofParams: Types.BlockProofParamsStruct,
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    swapCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    updateLightClient(
      blockProofParams: Types.BlockProofParamsStruct,
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    vaultCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawLiquidity(
      vault: Types.DepositVaultStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CIRCUIT_VERIFICATION_KEY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEPOSIT_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_ROUTER_ADDRESS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    TOKEN_DECIMALS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    VERIFIER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    accumulatedFeeBalance(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkpoints(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    depositLiquidity(
      params: Types.DepositLiquidityParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    depositLiquidityWithOverwrite(
      params: Types.DepositLiquidityWithOverwriteParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getLightClientHeight(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSwapCommitment(
      swapIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSwapCommitmentsLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultCommitment(
      vaultIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultCommitmentsLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mmrRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    payoutToFeeRouter(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    proveBlockInclusion(
      blockLeaf: Types.BlockLeafStruct,
      siblings: BytesLike[],
      peaks: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    releaseLiquidityBatch(
      paramsArray: Types.ReleaseLiquidityParamsStruct[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    submitBatchSwapProof(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    submitBatchSwapProofWithLightClientUpdate(
      swapParams: Types.SubmitSwapProofParamsStruct[],
      blockProofParams: Types.BlockProofParamsStruct,
      overwriteSwaps: Types.ProposedSwapStruct[],
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    swapCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateLightClient(
      blockProofParams: Types.BlockProofParamsStruct,
      proof: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    vaultCommitments(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdrawLiquidity(
      vault: Types.DepositVaultStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
